on:
  workflow_call:
    secrets:
      AWS_DEV_ACCOUNT_ID:
        required: true
      AWS_QA_ACCOUNT_ID:
        required: true
      AWS_PROD_ACCOUNT_ID:
        required: true
      AWS_PIPELINE_ACCESS_KEY_ID:
        required: true
      AWS_PIPELINE_SECRET_ACCESS_KEY:
        required: true
      PACKAGE_USERNAME:
        required: true
      PACKAGE_TOKEN:
        required: true
      NEW_RELIC_ACCOUNT_ID:
        required: true
      NEW_RELIC_INGEST_KEY_LAMBDA:
        required: true
      QUEUEIT_SECRET_KEY_DEV:
        required: false
      QUEUEIT_SECRET_KEY_QA:
        required: false
      QUEUEIT_SECRET_KEY_PROD:
        required: false
      QUEUEIT_API_KEY_DEV:
        required: false
      QUEUEIT_API_KEY_QA:
        required: false
      QUEUEIT_API_KEY_PROD:
        required: false
      QUEUEIT_CUSTOMER_ID_DEV:
        required: false
      QUEUEIT_CUSTOMER_ID_QA:
        required: false
      QUEUEIT_CUSTOMER_ID_PROD:
        required: false

env:
  BUILD_SHA: ${{ github.sha }}
  ACTIONS_ALLOW_UNSECURE_COMMANDS: true
  AWS_REGION: us-east-1
  ROLE_DURATION_SECONDS: 3600
  AWS_DEFAULT_OUTPUT: json
  AWS_DEPLOYMENT_ROLE: pipeline
  ORGANIZATION: lineup
  GITHUB_USERNAME: ${{ secrets.PACKAGE_USERNAME }}
  GITHUB_TOKEN: ${{ secrets.PACKAGE_TOKEN }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_PIPELINE_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_PIPELINE_SECRET_ACCESS_KEY }}
  NEW_RELIC_ACCOUNT_ID: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
  NEW_RELIC_INGEST_KEY_LAMBDA: ${{ secrets.NEW_RELIC_INGEST_KEY_LAMBDA }}
  LAMBDA_RUNTIME: nodejs20.x
  LAMBDA_HANDLER: index.handler
  LAMBDA_TIMEOUT: "5"
  LAMBDA_MEMORY_SIZE: "128"
  LAMBDA_VIEWER_REQUEST_NAME: lineup-queueit-viewer-request
  LAMBDA_VIEWER_RESPONSE_NAME: lineup-queueit-viewer-response

  # Publicar versiÃ³n al final (recomendado para Lambda@Edge)
  PUBLISH_VERSION: "true"


jobs:
  build-deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    steps:
    - name: Set DEV environment variables
      if: github.ref == 'refs/heads/dev'
      run: |
        echo "::set-env name=STAGE::dev"
        echo "::set-env name=AWS_ACCOUNT_ID::${{ secrets.AWS_DEV_ACCOUNT_ID }}"
        echo "::set-env name=LAMBDA_ROLE_ARN::arn:aws:iam::${{ secrets.AWS_DEV_ACCOUNT_ID }}:role/lineup-lambda-queueit"
        echo "::set-env name=QUEUEIT_SECRET_KEY::${{ secrets.QUEUEIT_SECRET_KEY_DEV }}"
        echo "::set-env name=QUEUEIT_API_KEY::${{ secrets.QUEUEIT_API_KEY_DEV }}"
        echo "::set-env name=QUEUEIT_CUSTOMER_ID::${{ secrets.QUEUEIT_CUSTOMER_ID_DEV }}"
    - name: Set QA environment variables
      if: github.ref == 'refs/heads/qa'
      run: |
        echo "::set-env name=STAGE::qa"
        echo "::set-env name=AWS_ACCOUNT_ID::${{ secrets.AWS_QA_ACCOUNT_ID }}"
        echo "::set-env name=LAMBDA_ROLE_ARN::arn:aws:iam::${{ secrets.AWS_QA_ACCOUNT_ID }}:role/lineup-lambda-queueit"
        echo "::set-env name=QUEUEIT_SECRET_KEY::${{ secrets.QUEUEIT_SECRET_KEY_QA }}"
        echo "::set-env name=QUEUEIT_API_KEY::${{ secrets.QUEUEIT_API_KEY_QA }}"
        echo "::set-env name=QUEUEIT_CUSTOMER_ID::${{ secrets.QUEUEIT_CUSTOMER_ID_QA }}"
    - name: Set PROD environment variables
      if: github.ref == 'refs/heads/prod'
      run: |
        echo "::set-env name=STAGE::prod"
        echo "::set-env name=AWS_ACCOUNT_ID::${{ secrets.AWS_PROD_ACCOUNT_ID }}"
        echo "::set-env name=LAMBDA_ROLE_ARN::arn:aws:iam::${{ secrets.AWS_PROD_ACCOUNT_ID }}:role/lineup-lambda-queueit"
        echo "::set-env name=QUEUEIT_SECRET_KEY::${{ secrets.QUEUEIT_SECRET_KEY_PROD }}"
        echo "::set-env name=QUEUEIT_API_KEY::${{ secrets.QUEUEIT_API_KEY_PROD }}"
        echo "::set-env name=QUEUEIT_CUSTOMER_ID::${{ secrets.QUEUEIT_CUSTOMER_ID_PROD }}"
    - name: ðŸ”‘ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        role-to-assume: ${{ format('arn:aws:iam::{0}:role/{1}', env.AWS_ACCOUNT_ID,env.AWS_DEPLOYMENT_ROLE) }}
        role-duration-seconds: ${{ env.ROLE_DURATION_SECONDS }}
    - name: Checkout
      uses: actions/checkout@v4
    - name: Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install dependencies
      run: npm ci

    - name: Inject Queue-it values into ViewerRequest/environmentvariables.json
      shell: bash
      env:
        QUEUEIT_SECRET_KEY: ${{ env.QUEUEIT_SECRET_KEY }}
        QUEUEIT_API_KEY: ${{ env.QUEUEIT_API_KEY }}
        QUEUEIT_CUSTOMER_ID: ${{ env.QUEUEIT_CUSTOMER_ID }}
      run: |
        set -euo pipefail

        # Valida secrets obligatorios
        [ -n "${QUEUEIT_SECRET_KEY}" ] || (echo "Falta secret QUEUEIT_SECRET_KEY" && exit 1)
        [ -n "${QUEUEIT_API_KEY}" ] || (echo "Falta secret QUEUEIT_API_KEY" && exit 1)
        [ -n "${QUEUEIT_CUSTOMER_ID}" ] || (echo "Falta secret QUEUEIT_CUSTOMER_ID" && exit 1)

        python3 - <<'PY'
        import json, os

        path = "ViewerRequest/environmentvariables.json"

        def parse_bool(v, default):
            if v is None or str(v).strip() == "":
                v = default
            return str(v).strip().lower() in ("1", "true", "yes", "y", "on")

        def parse_int(v, default):
            if v is None or str(v).strip() == "":
                v = default
            return int(str(v).strip())

        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Obligatorios
        data["QUEUEIT_SECRET_KEY"] = os.environ["QUEUEIT_SECRET_KEY"]
        data["QUEUEIT_API_KEY"] = os.environ["QUEUEIT_API_KEY"]
        data["QUEUEIT_CUSTOMER_ID"] = os.environ["QUEUEIT_CUSTOMER_ID"]

        # Opcionales con default
        data["QUEUEIT_ENQT_ENABLED"] = parse_bool(os.getenv("QUEUEIT_ENQT_ENABLED"), "true")
        data["QUEUEIT_ENQT_VALIDITY_TIME"] = parse_int(os.getenv("QUEUEIT_ENQT_VALIDITY_TIME"), "240000")
        data["QUEUEIT_ENQT_KEY_ENABLED"] = parse_bool(os.getenv("QUEUEIT_ENQT_KEY_ENABLED"), "false")

        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
            f.write("\n")
        PY


    - name: Build Queue-it artifacts
      run: npm run buildArtifacts

    - name: Validate generated ZIPs
      run: |
        set -euo pipefail
        ls -lah dist
        test -f dist/ViewerRequest.zip
        test -f dist/ViewerResponse.zip

    - name: Upsert ViewerRequest Lambda
      shell: bash
      run: |
        set -euo pipefail

        FUNCTION_NAME="${LAMBDA_VIEWER_REQUEST_NAME}-${STAGE}"
        ZIP_FILE="dist/ViewerRequest.zip"

        upsert_lambda() {
          local fn_name="$1"
          local zip_file="$2"

          echo "==> Procesando Lambda: ${fn_name}"
          echo "==> ZIP: ${zip_file}"

          if [[ ! -f "${zip_file}" ]]; then
            echo "ERROR: No existe ${zip_file}"
            exit 1
          fi

          if aws lambda get-function \
            --region "${AWS_REGION}" \
            --function-name "${fn_name}" >/dev/null 2>&1; then

            echo "La funciÃ³n existe, actualizando cÃ³digo..."
            aws lambda update-function-code \
              --region "${AWS_REGION}" \
              --function-name "${fn_name}" \
              --zip-file "fileb://${zip_file}" >/dev/null

            echo "âœ… CÃ³digo actualizado: ${fn_name}"
          else
            echo "La funciÃ³n no existe, creando..."
            aws lambda create-function \
              --region "${AWS_REGION}" \
              --function-name "${fn_name}" \
              --runtime "${LAMBDA_RUNTIME}" \
              --role "${LAMBDA_ROLE_ARN}" \
              --handler "${LAMBDA_HANDLER}" \
              --timeout "${LAMBDA_TIMEOUT}" \
              --memory-size "${LAMBDA_MEMORY_SIZE}" \
              --zip-file "fileb://${zip_file}" >/dev/null

            echo "âœ… FunciÃ³n creada: ${fn_name}"
          fi

          if [[ "${PUBLISH_VERSION}" == "true" ]]; then
            echo "Publicando versiÃ³n..."
            aws lambda publish-version \
              --region "${AWS_REGION}" \
              --function-name "${fn_name}" \
              --description "GitHub Actions ${GITHUB_SHA}" >/dev/null

            echo "âœ… VersiÃ³n publicada para ${fn_name}"
          fi
        }

        upsert_lambda "${FUNCTION_NAME}" "${ZIP_FILE}"

    - name: Upsert ViewerResponse Lambda
      shell: bash
      run: |
        set -euo pipefail

        FUNCTION_NAME="${LAMBDA_VIEWER_RESPONSE_NAME}-${STAGE}"
        ZIP_FILE="dist/ViewerResponse.zip"

        upsert_lambda() {
          local fn_name="$1"
          local zip_file="$2"

          echo "==> Procesando Lambda: ${fn_name}"
          echo "==> ZIP: ${zip_file}"

          if [[ ! -f "${zip_file}" ]]; then
            echo "ERROR: No existe ${zip_file}"
            exit 1
          fi

          if aws lambda get-function \
            --region "${AWS_REGION}" \
            --function-name "${fn_name}" >/dev/null 2>&1; then

            echo "La funciÃ³n existe, actualizando cÃ³digo..."
            aws lambda update-function-code \
              --region "${AWS_REGION}" \
              --function-name "${fn_name}" \
              --zip-file "fileb://${zip_file}" >/dev/null

            echo "âœ… CÃ³digo actualizado: ${fn_name}"
          else
            echo "La funciÃ³n no existe, creando..."
            aws lambda create-function \
              --region "${AWS_REGION}" \
              --function-name "${fn_name}" \
              --runtime "${LAMBDA_RUNTIME}" \
              --role "${LAMBDA_ROLE_ARN}" \
              --handler "${LAMBDA_HANDLER}" \
              --timeout "${LAMBDA_TIMEOUT}" \
              --memory-size "${LAMBDA_MEMORY_SIZE}" \
              --zip-file "fileb://${zip_file}" >/dev/null

            echo "âœ… FunciÃ³n creada: ${fn_name}"
          fi

          if [[ "${PUBLISH_VERSION}" == "true" ]]; then
            echo "Publicando versiÃ³n..."
            aws lambda publish-version \
              --region "${AWS_REGION}" \
              --function-name "${fn_name}" \
              --description "GitHub Actions ${GITHUB_SHA}" >/dev/null

            echo "âœ… VersiÃ³n publicada para ${fn_name}"
          fi
        }

        upsert_lambda "${FUNCTION_NAME}" "${ZIP_FILE}"

    # Opcional: tambiÃ©n subir artifacts (por si los quieres descargar)
    - name: Upload ViewerRequest artifact
      uses: actions/upload-artifact@v4
      with:
        name: ViewerRequest-zip
        path: dist/ViewerRequest.zip
        retention-days: 3

    - name: Upload ViewerResponse artifact
      uses: actions/upload-artifact@v4
      with:
        name: ViewerResponse-zip
        path: dist/ViewerResponse.zip
        retention-days: 3

    - name: Notify Slack on Failure
      if: failure()
      run: |
        curl -X POST --data-urlencode "payload={\"channel\": \"#pipeline-notifications\", \"username\": \"'${{ github.actor }}'\", \"text\": \"Workflow Lambda Queueit ${{ github.ref_name }} failed! See details: '${{ github.workflow }} - https://github.com/Nilo-Innovation/lineup-queueit-connector/actions'.\"}" ${{ secrets.SLACK_WEBHOOK_URL }}
    - name: Notify Slack on Success
      if: success()
      run: |
        curl -X POST --data-urlencode "payload={\"channel\": \"#pipeline-notifications\", \"username\": \"'${{ github.actor }}'\", \"text\": \"Workflow Lambda Queueit ${{ github.ref_name }} succeeded! See details: '${{ github.workflow }} - https://github.com/Nilo-Innovation/lineup-queueit-connector/actions'.\"}" ${{ secrets.SLACK_WEBHOOK_URL }}
